(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["arrow-key-navigation"],{

/***/ "./node_modules/arrow-key-navigation/dist-web/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/arrow-key-navigation/dist-web/index.js ***!
  \*************************************************************/
/*! exports provided: register, setFocusTrapTest, unregister */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"register\", function() { return register; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setFocusTrapTest\", function() { return setFocusTrapTest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unregister\", function() { return unregister; });\n/**\n * Makes it so the left and right arrows change focus, ala Tab/Shift+Tab. This is mostly designed\n * for KaiOS devices.\n */\n/* global document, addEventListener, removeEventListener, getSelection */\n// TODO: email/number types are a special type, in that they return selectionStart/selectionEnd as null\n// As far as I can tell, there is no way to actually get the caret position from these inputs. So we\n// don't do the proper caret handling for those inputs, unfortunately.\n// https://html.spec.whatwg.org/multipage/input.html#do-not-apply\nvar textInputTypes = ['text', 'search', 'url', 'password', 'tel'];\nvar checkboxRadioInputTypes = ['checkbox', 'radio'];\nvar focusTrapTest = undefined;\n// This query is adapted from a11y-dialog\n// https://github.com/edenspiekermann/a11y-dialog/blob/cf4ed81/a11y-dialog.js#L6-L18\nvar focusablesQuery = 'a[href], area[href], input, select, textarea, ' + 'button, iframe, object, embed, [contenteditable], [tabindex], ' + 'video[controls], audio[controls], summary';\nfunction getActiveElement() {\n  var activeElement = document.activeElement;\n  while (activeElement.shadowRoot) {\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\nfunction isFocusable(element) {\n  return element.matches(focusablesQuery) && !element.disabled && !/^-/.test(element.getAttribute('tabindex') || '') && !element.hasAttribute('inert') && (\n  // see https://github.com/GoogleChrome/inert-polyfill\n  element.offsetWidth > 0 || element.offsetHeight > 0);\n}\nfunction getFocusTrapParent(element) {\n  if (!focusTrapTest) {\n    return;\n  }\n  var parent = element.parentElement;\n  while (parent) {\n    if (focusTrapTest(parent)) {\n      return parent;\n    }\n    parent = parent.parentElement;\n  }\n}\nfunction shouldIgnoreEvent(activeElement, forwardDirection) {\n  var tagName = activeElement.tagName;\n  var isTextarea = tagName === 'TEXTAREA';\n  var isTextInput = tagName === 'INPUT' && textInputTypes.indexOf(activeElement.getAttribute('type').toLowerCase()) !== -1;\n  var isContentEditable = activeElement.hasAttribute('contenteditable');\n  if (!isTextarea && !isTextInput && !isContentEditable) {\n    return false;\n  }\n  var selectionStart;\n  var selectionEnd;\n  var len;\n  if (isContentEditable) {\n    var selection = getSelection();\n    selectionStart = selection.anchorOffset;\n    selectionEnd = selection.focusOffset;\n    len = activeElement.textContent.length;\n  } else {\n    selectionStart = activeElement.selectionStart;\n    selectionEnd = activeElement.selectionEnd;\n    len = activeElement.value.length;\n  }\n  // if the cursor is inside of a textarea/input, then don't focus to the next/previous element\n  // unless the cursor is at the beginning or the end\n  if (!forwardDirection && selectionStart === selectionEnd && selectionStart === 0) {\n    return false;\n  } else if (forwardDirection && selectionStart === selectionEnd && selectionStart === len) {\n    return false;\n  }\n  return true;\n}\nfunction getNextCandidateNodeForShadowDomPolyfill(root, targetElement, forwardDirection, filter) {\n  // When the shadydom polyfill is running, we can't use TreeWalker on ShadowRoots because\n  // they aren't real Nodes. So we do this workaround where we run TreeWalker on the\n  // children instead.\n  var nodes = Array.prototype.slice.call(root.querySelectorAll('*'));\n  var idx = nodes.indexOf(targetElement);\n  if (forwardDirection) {\n    nodes = nodes.slice(idx + 1);\n  } else {\n    if (idx === -1) {\n      idx = nodes.length;\n    }\n    nodes = nodes.slice(0, idx);\n    nodes.reverse();\n  }\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (node instanceof HTMLElement && filter.acceptNode(node) === NodeFilter.FILTER_ACCEPT) {\n      return node;\n    }\n  }\n  return undefined;\n}\nfunction getNextCandidateNode(root, targetElement, forwardDirection, filter) {\n  var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filter);\n  if (targetElement) {\n    walker.currentNode = targetElement;\n  }\n  if (forwardDirection) {\n    return walker.nextNode();\n  } else if (targetElement) {\n    return walker.previousNode();\n  }\n  // iterating backwards through shadow root, use last child\n  return walker.lastChild();\n}\nfunction isShadowDomPolyfill() {\n  return typeof ShadowRoot !== 'undefined' && (\n  // ShadowRoot.polyfill is just a hack for our unit tests\n  'polyfill' in ShadowRoot || !ShadowRoot.toString().includes('[native code]'));\n}\nfunction getNextNode(root, targetElement, forwardDirection) {\n  var filter = {\n    acceptNode: function acceptNode(node) {\n      return node === targetElement || node.shadowRoot || isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  };\n  // TODO: remove this when we don't need to support the Shadow DOM polyfill\n  var nextNode = isShadowDomPolyfill() && root instanceof ShadowRoot ? getNextCandidateNodeForShadowDomPolyfill(root, targetElement, forwardDirection, filter) : getNextCandidateNode(root, targetElement, forwardDirection, filter);\n  if (nextNode && nextNode.shadowRoot) {\n    // push into the shadow DOM\n    return getNextNode(nextNode.shadowRoot, null, forwardDirection);\n  }\n  if (!nextNode && root.host) {\n    // pop out of the shadow DOM\n    return getNextNode(root.host.getRootNode(), root.host, forwardDirection);\n  }\n  return nextNode;\n}\nfunction focusNextOrPrevious(event, key) {\n  var activeElement = getActiveElement();\n  var forwardDirection = key === 'ArrowRight';\n  if (shouldIgnoreEvent(activeElement, forwardDirection)) {\n    return;\n  }\n  var root = getFocusTrapParent(activeElement) || activeElement.getRootNode();\n  var nextNode = getNextNode(root, activeElement, forwardDirection);\n  if (nextNode && nextNode !== activeElement) {\n    nextNode.focus();\n    event.preventDefault();\n  }\n}\nfunction handleEnter(event) {\n  var activeElement = getActiveElement();\n  if (activeElement.tagName === 'INPUT' && checkboxRadioInputTypes.indexOf(activeElement.getAttribute('type').toLowerCase()) !== -1) {\n    // Explicitly override \"enter\" on an input and make it fire the checkbox/radio\n    activeElement.click();\n    event.preventDefault();\n  }\n}\nfunction keyListener(event) {\n  if (event.altKey || event.metaKey || event.ctrlKey) {\n    return; // ignore e.g. Alt-Left and Ctrl-Right, which are used to switch browser tabs or navigate back/forward\n  }\n\n  var key = event.key;\n  switch (key) {\n    case 'ArrowLeft':\n    case 'ArrowRight':\n      {\n        focusNextOrPrevious(event, key);\n        break;\n      }\n    case 'Enter':\n      {\n        handleEnter(event);\n        break;\n      }\n  }\n}\n/**\n * Start listening for keyboard events. Attaches a listener to the window.\n */\nfunction register() {\n  addEventListener('keydown', keyListener);\n}\n/**\n * Stop listening for keyboard events. Unattaches a listener to the window.\n */\nfunction unregister() {\n  removeEventListener('keydown', keyListener);\n}\n/**\n * Set a focus trap test to identify any focus traps in the DOM, i.e. a top-level DOM node that indicates the root\n * of a focus trap. Once this is set, if focus changes within the focus trap, then will not leave the focus trap.\n * @param test: the test function\n * @see https://w3c.github.io/aria-practices/examples/dialog-modal/dialog.html\n */\nfunction setFocusTrapTest(test) {\n  focusTrapTest = test;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXJyb3cta2V5LW5hdmlnYXRpb24vZGlzdC13ZWIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXJyb3cta2V5LW5hdmlnYXRpb24vZGlzdC13ZWIvaW5kZXguanM/ZjEyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1ha2VzIGl0IHNvIHRoZSBsZWZ0IGFuZCByaWdodCBhcnJvd3MgY2hhbmdlIGZvY3VzLCBhbGEgVGFiL1NoaWZ0K1RhYi4gVGhpcyBpcyBtb3N0bHkgZGVzaWduZWRcbiAqIGZvciBLYWlPUyBkZXZpY2VzLlxuICovXG4vKiBnbG9iYWwgZG9jdW1lbnQsIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGdldFNlbGVjdGlvbiAqL1xuLy8gVE9ETzogZW1haWwvbnVtYmVyIHR5cGVzIGFyZSBhIHNwZWNpYWwgdHlwZSwgaW4gdGhhdCB0aGV5IHJldHVybiBzZWxlY3Rpb25TdGFydC9zZWxlY3Rpb25FbmQgYXMgbnVsbFxuLy8gQXMgZmFyIGFzIEkgY2FuIHRlbGwsIHRoZXJlIGlzIG5vIHdheSB0byBhY3R1YWxseSBnZXQgdGhlIGNhcmV0IHBvc2l0aW9uIGZyb20gdGhlc2UgaW5wdXRzLiBTbyB3ZVxuLy8gZG9uJ3QgZG8gdGhlIHByb3BlciBjYXJldCBoYW5kbGluZyBmb3IgdGhvc2UgaW5wdXRzLCB1bmZvcnR1bmF0ZWx5LlxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5wdXQuaHRtbCNkby1ub3QtYXBwbHlcbnZhciB0ZXh0SW5wdXRUeXBlcyA9IFsndGV4dCcsICdzZWFyY2gnLCAndXJsJywgJ3Bhc3N3b3JkJywgJ3RlbCddO1xudmFyIGNoZWNrYm94UmFkaW9JbnB1dFR5cGVzID0gWydjaGVja2JveCcsICdyYWRpbyddO1xudmFyIGZvY3VzVHJhcFRlc3QgPSB1bmRlZmluZWQ7XG4vLyBUaGlzIHF1ZXJ5IGlzIGFkYXB0ZWQgZnJvbSBhMTF5LWRpYWxvZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2VkZW5zcGlla2VybWFubi9hMTF5LWRpYWxvZy9ibG9iL2NmNGVkODEvYTExeS1kaWFsb2cuanMjTDYtTDE4XG52YXIgZm9jdXNhYmxlc1F1ZXJ5ID0gJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCAnICsgJ2J1dHRvbiwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCBbY29udGVudGVkaXRhYmxlXSwgW3RhYmluZGV4XSwgJyArICd2aWRlb1tjb250cm9sc10sIGF1ZGlvW2NvbnRyb2xzXSwgc3VtbWFyeSc7XG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KCkge1xuICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIHdoaWxlIChhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpIHtcbiAgICBhY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0ZvY3VzYWJsZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoZm9jdXNhYmxlc1F1ZXJ5KSAmJiAhZWxlbWVudC5kaXNhYmxlZCAmJiAhL14tLy50ZXN0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpIHx8ICcnKSAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykgJiYgKFxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS9pbmVydC1wb2x5ZmlsbFxuICBlbGVtZW50Lm9mZnNldFdpZHRoID4gMCB8fCBlbGVtZW50Lm9mZnNldEhlaWdodCA+IDApO1xufVxuZnVuY3Rpb24gZ2V0Rm9jdXNUcmFwUGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFmb2N1c1RyYXBUZXN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAoZm9jdXNUcmFwVGVzdChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkSWdub3JlRXZlbnQoYWN0aXZlRWxlbWVudCwgZm9yd2FyZERpcmVjdGlvbikge1xuICB2YXIgdGFnTmFtZSA9IGFjdGl2ZUVsZW1lbnQudGFnTmFtZTtcbiAgdmFyIGlzVGV4dGFyZWEgPSB0YWdOYW1lID09PSAnVEVYVEFSRUEnO1xuICB2YXIgaXNUZXh0SW5wdXQgPSB0YWdOYW1lID09PSAnSU5QVVQnICYmIHRleHRJbnB1dFR5cGVzLmluZGV4T2YoYWN0aXZlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKS50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG4gIHZhciBpc0NvbnRlbnRFZGl0YWJsZSA9IGFjdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgaWYgKCFpc1RleHRhcmVhICYmICFpc1RleHRJbnB1dCAmJiAhaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHNlbGVjdGlvblN0YXJ0O1xuICB2YXIgc2VsZWN0aW9uRW5kO1xuICB2YXIgbGVuO1xuICBpZiAoaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKCk7XG4gICAgc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgIHNlbGVjdGlvbkVuZCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgICBsZW4gPSBhY3RpdmVFbGVtZW50LnRleHRDb250ZW50Lmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb25TdGFydCA9IGFjdGl2ZUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgc2VsZWN0aW9uRW5kID0gYWN0aXZlRWxlbWVudC5zZWxlY3Rpb25FbmQ7XG4gICAgbGVuID0gYWN0aXZlRWxlbWVudC52YWx1ZS5sZW5ndGg7XG4gIH1cbiAgLy8gaWYgdGhlIGN1cnNvciBpcyBpbnNpZGUgb2YgYSB0ZXh0YXJlYS9pbnB1dCwgdGhlbiBkb24ndCBmb2N1cyB0byB0aGUgbmV4dC9wcmV2aW91cyBlbGVtZW50XG4gIC8vIHVubGVzcyB0aGUgY3Vyc29yIGlzIGF0IHRoZSBiZWdpbm5pbmcgb3IgdGhlIGVuZFxuICBpZiAoIWZvcndhcmREaXJlY3Rpb24gJiYgc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCAmJiBzZWxlY3Rpb25TdGFydCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChmb3J3YXJkRGlyZWN0aW9uICYmIHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQgJiYgc2VsZWN0aW9uU3RhcnQgPT09IGxlbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldE5leHRDYW5kaWRhdGVOb2RlRm9yU2hhZG93RG9tUG9seWZpbGwocm9vdCwgdGFyZ2V0RWxlbWVudCwgZm9yd2FyZERpcmVjdGlvbiwgZmlsdGVyKSB7XG4gIC8vIFdoZW4gdGhlIHNoYWR5ZG9tIHBvbHlmaWxsIGlzIHJ1bm5pbmcsIHdlIGNhbid0IHVzZSBUcmVlV2Fsa2VyIG9uIFNoYWRvd1Jvb3RzIGJlY2F1c2VcbiAgLy8gdGhleSBhcmVuJ3QgcmVhbCBOb2Rlcy4gU28gd2UgZG8gdGhpcyB3b3JrYXJvdW5kIHdoZXJlIHdlIHJ1biBUcmVlV2Fsa2VyIG9uIHRoZVxuICAvLyBjaGlsZHJlbiBpbnN0ZWFkLlxuICB2YXIgbm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChyb290LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7XG4gIHZhciBpZHggPSBub2Rlcy5pbmRleE9mKHRhcmdldEVsZW1lbnQpO1xuICBpZiAoZm9yd2FyZERpcmVjdGlvbikge1xuICAgIG5vZGVzID0gbm9kZXMuc2xpY2UoaWR4ICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIGlkeCA9IG5vZGVzLmxlbmd0aDtcbiAgICB9XG4gICAgbm9kZXMgPSBub2Rlcy5zbGljZSgwLCBpZHgpO1xuICAgIG5vZGVzLnJldmVyc2UoKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGZpbHRlci5hY2NlcHROb2RlKG5vZGUpID09PSBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0TmV4dENhbmRpZGF0ZU5vZGUocm9vdCwgdGFyZ2V0RWxlbWVudCwgZm9yd2FyZERpcmVjdGlvbiwgZmlsdGVyKSB7XG4gIHZhciB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHJvb3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCBmaWx0ZXIpO1xuICBpZiAodGFyZ2V0RWxlbWVudCkge1xuICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IHRhcmdldEVsZW1lbnQ7XG4gIH1cbiAgaWYgKGZvcndhcmREaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gd2Fsa2VyLm5leHROb2RlKCk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0RWxlbWVudCkge1xuICAgIHJldHVybiB3YWxrZXIucHJldmlvdXNOb2RlKCk7XG4gIH1cbiAgLy8gaXRlcmF0aW5nIGJhY2t3YXJkcyB0aHJvdWdoIHNoYWRvdyByb290LCB1c2UgbGFzdCBjaGlsZFxuICByZXR1cm4gd2Fsa2VyLmxhc3RDaGlsZCgpO1xufVxuZnVuY3Rpb24gaXNTaGFkb3dEb21Qb2x5ZmlsbCgpIHtcbiAgcmV0dXJuIHR5cGVvZiBTaGFkb3dSb290ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIC8vIFNoYWRvd1Jvb3QucG9seWZpbGwgaXMganVzdCBhIGhhY2sgZm9yIG91ciB1bml0IHRlc3RzXG4gICdwb2x5ZmlsbCcgaW4gU2hhZG93Um9vdCB8fCAhU2hhZG93Um9vdC50b1N0cmluZygpLmluY2x1ZGVzKCdbbmF0aXZlIGNvZGVdJykpO1xufVxuZnVuY3Rpb24gZ2V0TmV4dE5vZGUocm9vdCwgdGFyZ2V0RWxlbWVudCwgZm9yd2FyZERpcmVjdGlvbikge1xuICB2YXIgZmlsdGVyID0ge1xuICAgIGFjY2VwdE5vZGU6IGZ1bmN0aW9uIGFjY2VwdE5vZGUobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUgPT09IHRhcmdldEVsZW1lbnQgfHwgbm9kZS5zaGFkb3dSb290IHx8IGlzRm9jdXNhYmxlKG5vZGUpID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUIDogTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICB9XG4gIH07XG4gIC8vIFRPRE86IHJlbW92ZSB0aGlzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0byBzdXBwb3J0IHRoZSBTaGFkb3cgRE9NIHBvbHlmaWxsXG4gIHZhciBuZXh0Tm9kZSA9IGlzU2hhZG93RG9tUG9seWZpbGwoKSAmJiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IGdldE5leHRDYW5kaWRhdGVOb2RlRm9yU2hhZG93RG9tUG9seWZpbGwocm9vdCwgdGFyZ2V0RWxlbWVudCwgZm9yd2FyZERpcmVjdGlvbiwgZmlsdGVyKSA6IGdldE5leHRDYW5kaWRhdGVOb2RlKHJvb3QsIHRhcmdldEVsZW1lbnQsIGZvcndhcmREaXJlY3Rpb24sIGZpbHRlcik7XG4gIGlmIChuZXh0Tm9kZSAmJiBuZXh0Tm9kZS5zaGFkb3dSb290KSB7XG4gICAgLy8gcHVzaCBpbnRvIHRoZSBzaGFkb3cgRE9NXG4gICAgcmV0dXJuIGdldE5leHROb2RlKG5leHROb2RlLnNoYWRvd1Jvb3QsIG51bGwsIGZvcndhcmREaXJlY3Rpb24pO1xuICB9XG4gIGlmICghbmV4dE5vZGUgJiYgcm9vdC5ob3N0KSB7XG4gICAgLy8gcG9wIG91dCBvZiB0aGUgc2hhZG93IERPTVxuICAgIHJldHVybiBnZXROZXh0Tm9kZShyb290Lmhvc3QuZ2V0Um9vdE5vZGUoKSwgcm9vdC5ob3N0LCBmb3J3YXJkRGlyZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gbmV4dE5vZGU7XG59XG5mdW5jdGlvbiBmb2N1c05leHRPclByZXZpb3VzKGV2ZW50LCBrZXkpIHtcbiAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHZhciBmb3J3YXJkRGlyZWN0aW9uID0ga2V5ID09PSAnQXJyb3dSaWdodCc7XG4gIGlmIChzaG91bGRJZ25vcmVFdmVudChhY3RpdmVFbGVtZW50LCBmb3J3YXJkRGlyZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcm9vdCA9IGdldEZvY3VzVHJhcFBhcmVudChhY3RpdmVFbGVtZW50KSB8fCBhY3RpdmVFbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gIHZhciBuZXh0Tm9kZSA9IGdldE5leHROb2RlKHJvb3QsIGFjdGl2ZUVsZW1lbnQsIGZvcndhcmREaXJlY3Rpb24pO1xuICBpZiAobmV4dE5vZGUgJiYgbmV4dE5vZGUgIT09IGFjdGl2ZUVsZW1lbnQpIHtcbiAgICBuZXh0Tm9kZS5mb2N1cygpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUVudGVyKGV2ZW50KSB7XG4gIHZhciBhY3RpdmVFbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICBpZiAoYWN0aXZlRWxlbWVudC50YWdOYW1lID09PSAnSU5QVVQnICYmIGNoZWNrYm94UmFkaW9JbnB1dFR5cGVzLmluZGV4T2YoYWN0aXZlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKS50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpIHtcbiAgICAvLyBFeHBsaWNpdGx5IG92ZXJyaWRlIFwiZW50ZXJcIiBvbiBhbiBpbnB1dCBhbmQgbWFrZSBpdCBmaXJlIHRoZSBjaGVja2JveC9yYWRpb1xuICAgIGFjdGl2ZUVsZW1lbnQuY2xpY2soKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59XG5mdW5jdGlvbiBrZXlMaXN0ZW5lcihldmVudCkge1xuICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkge1xuICAgIHJldHVybjsgLy8gaWdub3JlIGUuZy4gQWx0LUxlZnQgYW5kIEN0cmwtUmlnaHQsIHdoaWNoIGFyZSB1c2VkIHRvIHN3aXRjaCBicm93c2VyIHRhYnMgb3IgbmF2aWdhdGUgYmFjay9mb3J3YXJkXG4gIH1cblxuICB2YXIga2V5ID0gZXZlbnQua2V5O1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICB7XG4gICAgICAgIGZvY3VzTmV4dE9yUHJldmlvdXMoZXZlbnQsIGtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgIHtcbiAgICAgICAgaGFuZGxlRW50ZXIoZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuLyoqXG4gKiBTdGFydCBsaXN0ZW5pbmcgZm9yIGtleWJvYXJkIGV2ZW50cy4gQXR0YWNoZXMgYSBsaXN0ZW5lciB0byB0aGUgd2luZG93LlxuICovXG5mdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleUxpc3RlbmVyKTtcbn1cbi8qKlxuICogU3RvcCBsaXN0ZW5pbmcgZm9yIGtleWJvYXJkIGV2ZW50cy4gVW5hdHRhY2hlcyBhIGxpc3RlbmVyIHRvIHRoZSB3aW5kb3cuXG4gKi9cbmZ1bmN0aW9uIHVucmVnaXN0ZXIoKSB7XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlMaXN0ZW5lcik7XG59XG4vKipcbiAqIFNldCBhIGZvY3VzIHRyYXAgdGVzdCB0byBpZGVudGlmeSBhbnkgZm9jdXMgdHJhcHMgaW4gdGhlIERPTSwgaS5lLiBhIHRvcC1sZXZlbCBET00gbm9kZSB0aGF0IGluZGljYXRlcyB0aGUgcm9vdFxuICogb2YgYSBmb2N1cyB0cmFwLiBPbmNlIHRoaXMgaXMgc2V0LCBpZiBmb2N1cyBjaGFuZ2VzIHdpdGhpbiB0aGUgZm9jdXMgdHJhcCwgdGhlbiB3aWxsIG5vdCBsZWF2ZSB0aGUgZm9jdXMgdHJhcC5cbiAqIEBwYXJhbSB0ZXN0OiB0aGUgdGVzdCBmdW5jdGlvblxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vYXJpYS1wcmFjdGljZXMvZXhhbXBsZXMvZGlhbG9nLW1vZGFsL2RpYWxvZy5odG1sXG4gKi9cbmZ1bmN0aW9uIHNldEZvY3VzVHJhcFRlc3QodGVzdCkge1xuICBmb2N1c1RyYXBUZXN0ID0gdGVzdDtcbn1cbmV4cG9ydCB7IHJlZ2lzdGVyLCBzZXRGb2N1c1RyYXBUZXN0LCB1bnJlZ2lzdGVyIH07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/arrow-key-navigation/dist-web/index.js\n");

/***/ })

}]);